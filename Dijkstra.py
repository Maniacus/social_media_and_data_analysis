def dijkstra(graph, start):
    # Изначально все расстояния условно бесконечны (999)
    dist = {node: 999 for node in graph} 
    # Устанавливаем расстояние до стартовой вершины равной 0
    dist[start] = 0  
    # Очередь, изначально содержит только передаваемую в функцию вершину
    queue = [start]  
    
    # Условие выполняется пока очередь не пуста
    while queue:
        # Выбираем первую вершину из очереди, (удаляя ее из очереди)
        current_node = queue.pop(0)
        # Проходим по всем смежным вершинам
        for neighbor in graph[current_node]:
            # Поиск короткого пути для смежной вершины
            # Если значение расстояние смежной вершины больше чем значение расстояние для текущей вершины +1, то добавляем смежной вершине это растояние + 1
            if dist[neighbor] > dist[current_node] + 1:
                dist[neighbor] = dist[current_node] + 1
                # Добавляем смежную вершину в очередь, и повторяем цикл для нее
                queue.append(neighbor)  
    return dist

# Граф (список смежности)
graph = {
    'A': ['B'],
    'B': ['A', 'C', 'D', 'F'],
    'C': ['B'],
    'D': ['B', 'E'],
    'E': ['D'],
    'F': ['B', 'H', 'J'],
    'H': ['F'],
    'J': ['F']
}

# Указываем начальную вершину, от которой пойдет поиск
start_node = 'A'
result = dijkstra(graph, start_node)
print(result)